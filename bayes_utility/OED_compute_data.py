'''
This file runs the OED test for investigating the effects of
various wind strengths and noise levels on the usefulness of
various lengths of time series

Note: this file takes a long time to run. The output data can be found in the
folder "output_data", and the figures generated by running
"plot_oed_results.ipynb"
'''

import sys, os
from hcipy import *
import h5py
import numpy as np

import scipy

# Location of imports for this project
curdir = os.getcwd(); srcdir = "src"
sys.path.append(os.path.join(curdir, srcdir))

from gp_util import *
import helpers

# Locations of input and output files
indata = "input_data"
outdata = "output_data"

DorA = 'A'

filename = 'matrix_for_GP_41x41.mat'
filepath = os.path.join(curdir, indata, filename)
arrays = {}
f = h5py.File(filepath,'r')
for k, v in f.items():
    arrays[k] = np.array(v)

# the fried SH matrix
G_full = arrays["G_1"]
G_full = G_full.transpose()
# G_2 = arrays["G_2"]
print(G_full.shape)

framerate = 0.002

def generate_evenly_spaced_vectors(num_vectors):
    angles = np.linspace(0, 2 * np.pi, num_vectors, endpoint=False)
    vectors = np.array([(np.cos(angle), np.sin(angle)) for angle in angles])
    return vectors

with open('output_data/results_A.txt', 'w') as f:
    f.write('# wind, noise_var, data\n')
    wind_strengths = [5,15, 25, 40]
    noise_vars = [0.01, 0.1, 0.25, 1.0]
    for wind in wind_strengths:
        wind = framerate*wind
        for noise_var in noise_vars:
            print(f'Wind strength: {wind}, noise_var: {noise_var}')
            Opt_vals = []
            timesteps = range(1,20,3)
            winds = np.array([[wind, 0], [0, wind], [wind/np.sqrt(2), wind/np.sqrt(2)]])
            Cn2 = np.array([0.5, 0.3, 0.2])
            print(f'Computing timesteps from {timesteps[0]} to {timesteps[-1]}:')
            for i in timesteps:
                print(i)
                if DorA == 'D':
                    Opt_vals.append(D_opt_data(i, G_full, winds_iso, noise_var))
                else:
                    Opt_vals.append(A_opt_data(i, G_full, winds, Cn2, noise_var))
            f.write(f'{wind}, {noise_var}')
            for val in Opt_vals:
                f.write(f',{val:.6f}')
            f.write('\n')

with open('output_data/results_A_iso.txt', 'w') as f:
    f.write('# wind, noise_var, data\n')
    wind_strengths = [5,15, 25, 40]
    noise_vars = [0.01, 0.1, 0.25, 1.0]
    for wind in wind_strengths:
        # wind = framerate*wind
        for noise_var in noise_vars:
            print(f'Wind strength: {wind}, noise_var: {noise_var}, isotropic')
            Opt_vals = []
            timesteps = range(1,20,3)
            n_int = 50
            Cn2_iso = np.ones(n_int)*1/n_int
            winds_iso = framerate*wind*generate_evenly_spaced_vectors(n_int)
            print(f'Computing timesteps from {timesteps[0]} to {timesteps[-1]}:')
            for i in timesteps:
                print(i)
                if DorA == 'D':
                    Opt_vals.append(D_opt_data(i, G_full, winds_iso, noise_var))
                else:
                    Opt_vals.append(A_opt_data(i, G_full, winds_iso, Cn2_iso, noise_var))
            f.write(f'{wind}, {noise_var}')
            for val in Opt_vals:
                f.write(f',{val:.6f}')
            f.write('\n')

# Compute OED criteria for S-GP

nLenslet = 41
ndm = nLenslet + 1
telescope_diameter = 8.

wavelength_wfs = 0.7e-6

n_history = 1 # data steps
predict = 2 # predective steps

fried_grid = make_pupil_grid(ndm, telescope_diameter)

# just spatial covariance
r0 = 0.168 # m
L0 = 40 # meter
Cn2 = np.array([0.5, 0.3, 0.2])
timesteps = n_history + predict
framerate = 0.002
N = G_full.shape[1]

cov_mat_spatial = spatial_covmat(fried_grid, r0, L0)
# cov_function = phase_covariance_von_karman(r0, L0)
# temporal_variance = np.zeros((timesteps,))
# for i in range(timesteps):
#     shifted_grid = x.shifted(x[0] + [avg_wind*i*framerate, 0])
#     temporal_variance[i] = cov_function(shifted_grid)
# temporal_variance = temporal_variance/temporal_variance[0]


with open('output_data/results_spatial.txt', 'w') as f:
    f.write('# wind, noise_var, data\n')
    wind_strengths = [5,15, 25, 40]
    noise_vars = [0.01, 0.1, 0.25, 1.0]
    for wind in wind_strengths:
        wind = framerate*wind
        for signal_to_noise in noise_vars:
            print(f'Wind strength: {wind}, noise_var: {signal_to_noise}, isotropic')
            Opt_vals = []
            winds = np.array([[wind, 0], [0, wind], [wind/np.sqrt(2), wind/np.sqrt(2)]])
            Cn2 = np.array([0.5, 0.3, 0.2])
            cov_mat = spatio_temporal_covmat(timesteps, Cn2, winds, cov_mat_spatial, fried_grid, r0, L0)
            signal_variance = G_full@cov_mat_spatial@G_full.transpose()
            signal_strength = np.mean(np.diag(signal_variance))
            noise_var = (signal_to_noise**2) * signal_strength
            A = scipy.linalg.block_diag(*([G_full] * n_history))
            A = np.concatenate((A, np.zeros((A.shape[0], predict * G_full.shape[1]))),1)
            # Opt_vals.append(A_opt_data(i, G_full, winds_iso, Cn2_iso, noise_var))
            # Compute posterior covariance for spatial model
            C_spatial_inv = np.linalg.inv(cov_mat_spatial)

            C_post_spatial_inv = G_full.transpose() @ ((1/noise_var)*np.eye(G_full.shape[0])) @ G_full  +  C_spatial_inv
            C_post_spatial =  np.linalg.inv(C_post_spatial_inv)
            C_post_pred = C_post_spatial[-N:,-N:]
            u, s, vh = np.linalg.svd(C_post_pred, full_matrices=True)
            s[0] = 0
            C_post_pred2 = u @ np.diag(s) @ vh
            var = np.diagonal(C_post_pred2)
            var = var + 2*cov_mat[0,0] - 2*cov_mat[(2)*N,0]
            val = np.sqrt(np.sum(var))
            f.write(f'{wind}, {noise_var}, {val:.6f}')
            f.write('\n')
